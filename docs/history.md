# SMP発想の歴史

## はじまり：EelとGUI制御の限界

当初、PythonとHTMLをつなぐ手段としてEelを採用した。
PythonからHTML/CSS/JavaScriptを呼び出すこの手法は一見スマートで、簡単にGUIを構築できるように思えた。
しかし、HTML側の構造を意識し、JavaScript側でイベントハンドラやレイアウトを細かく調整するうちに、
「これでは本質的にPythonだけで制御できるとは言えないのではないか？」という疑問が強くなった。

## draw.ioとの連携を試みる

そこでGUIの視覚設計をもっと直感的に行いたいという思いから、
draw.ioで作ったレイアウトデータ（XML）をTkinterへ変換しようと試みた。
しかし、Tkinterが持つウィジェットと、draw.ioの持つ図形要素との間には構造的な乖離があり、
思った通りに見た目を再現できず、GUI表現の一貫性が崩れてしまった。

## 発想の転換：SVGというキャンバス

GUIを「構築する」のではなく「描く」ものと捉え直し、
SVGを用いることでその問題が大きく改善された。
SVGは構造も位置情報もレイアウトもすべて定義済みで、しかもHTMLにそのまま埋め込める。
Inkscapeなどのエディタでtype="button"のような属性を加えることで、
部品としての意味付けも可能になると分かった。

この時点で、GUI表現にHTML/CSS/JSを直接触る必要がなくなりつつあった。
SVGは、視覚表現と構造定義を同時に持つ理想的なGUI定義言語となった。

## 新たな課題：バックエンドとの接続

SVGがGUI定義として機能するようになると、
次に問題となったのはPython側とどう通信するかという点だった。
当初はWebSocketでトンネルを張り、JavaScriptとPythonの1対1通信を成立させる方法を採った。
ローカル環境では問題なく動作したが、Web上での運用や複数ブラウザからの接続を考慮すると、
セッション管理やペアリング情報の保存が避けられず、Redis等の導入が必要になってしまった。

## 突破口：MQTTの導入

この状況を打開する鍵として浮上してきたのがMQTTだった。
MQTTは元々IoT向けに設計された軽量なメッセージングプロトコルで、
トピックベースのpub/sub通信により、送受信者のペアリングを必要としない。

セッションIDを含んだトピック名を設計することで、
通信のルーティングが自動で解決され、ペアリング情報の保存が不要になる。
さらに、WebSocket over TLS (wss://) により、ブラウザ上でも安全に接続が可能となった。

これにより、GUIはSVGで定義され、イベントはJavaScriptからMQTT経由でPythonに送信され、
Pythonが処理結果を同じくMQTTで返す、という完全分離かつ疎結合な構造が成立した。

## SMPの誕生

こうして生まれたのが、SMP = SVG + MQTT + Python という新しい発想である。

- GUIは描くもの（SVG）
- 通信は流すもの（MQTT）
- 挙動は制御するもの（Python）

という三分離の構造により、HTML/CSS/JavaScriptには直接触れる必要がなくなった。
それらはただの実行基盤、ランタイムとして定義済みの枠組みに収まった。
GUI設計とロジック設計が視覚的にも論理的にも明確に分離されるこの構成は、
開発効率と可読性、拡張性を大きく向上させることが分かってきた。

## これから

このフレームワークの完成にはまだ時間がかかる。
SVG構造のルール整備、MQTTトピック設計の抽象化、Python側の処理テンプレート化など、
解決すべき課題は多い。

だが、この流れは「GUIとは何か？」という根本的な問いへの一つの答えである。
その思想と実装が融合したとき、SMPは従来のWebアプリ構築の限界を乗り越える可能性を秘めている。

==============================
